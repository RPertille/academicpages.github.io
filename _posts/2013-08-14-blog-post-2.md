---
title: 'Blog Post number 2'
date: 2013-08-14
permalink: /posts/2013/08/blog-post-2/
tags:
  - cool posts
  - category1
  - category2
---
# **Base R - Ambiente de trabalho**

### **Objetos, operações e funções**

#### **Operações Matemáticas**


Base R - Ambiente de trabalho
Objetos, operações e funções
Operações Matemáticas
'
1 + 1 
'
## [1] 2

4 - 2

## [1] 2

2 * 3

## [1] 6

5 / 3

## [1] 1.666667

4 ^ 2

## [1] 16

40/3 * 2

## [1] 26.66667

(40 + 5 + 23) * 2

## [1] 136

pi/5

## [1] 0.6283185

Criando Objetos
- Sempre procurar usar para nomes de objetos, principalmente para os longos, o uso de “_“, evitando outros tipos de símbolos que podem causar problemas.

v_1 <- "UTFPR"  ##o sinal " <- " significa atribuição
v_1

## [1] "UTFPR"

v_2 <- c(1,2.5,40,32) # isso é um vetor

- Utilizando o parenteses na linha de comando, ao rodar o resultado já é mostrado na tela.

(v_2 <- c(1,2.5,40,32))

## [1]  1.0  2.5 40.0 32.0

- Ao escrever uma função deve-se ficar atento aos parenteses. Caso o R entenda que está faltando algo ele avisará e em alguns casos aparecerá um “+” para você colocar oque falta.
- Fazendo operações com vetores

v_3 <- v_2 - 1
v_3

## [1]  0.0  1.5 39.0 31.0

v_4 <- v_3/2
v_4

## [1]  0.00  0.75 19.50 15.50

v_5 <- v_4*3
v_5

## [1]  0.00  2.25 58.50 46.50

v_6 <- v_2 + v_3 + v_4 + v_5
v_6

## [1]   1   7 157 125

Matrizes
- A matriz nada mais é que um vetor com duas dimensões, ou seja, linha e coluna. Aceita penas um tipos de classe (não pode ter numérico e caractere junto por exemplo)

?matrix

## starting httpd help server ... done

m1 <- matrix(1:8, nrow = 2, ncol = 4)
m1

##      [,1] [,2] [,3] [,4]
## [1,]    1    3    5    7
## [2,]    2    4    6    8

m2 <- matrix(1:20, 5, 4)
m2

##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20

Listas
listas permitem armazenar dados de classes diferentes e de comprimentos diferentes

l1 <- list(Universidade = v_1, Campus= "Pato Branco", Curso = "Agronomia", Dia = Sys.time())
l1

## $Universidade
## [1] "UTFPR"
## 
## $Campus
## [1] "Pato Branco"
## 
## $Curso
## [1] "Agronomia"
## 
## $Dia
## [1] "2018-10-08 15:46:12 -03"

Data Frame
- O data frame é a forma de guardar dados mais importante quando se fala em análise de dados. Ele permite que tenha várias classes, porém todas as variáveis devem ter o mesmo comprimento (ex.: mesma quantidadde de linha). Outra observação importante é que um data frame deve ser organizado de forma que cada coluna represente uma variável e que cada linha represente uma observação (Unidade experimental).

npk  # Isso é um dataframe

##    block N P K yield
## 1      1 0 1 1  49.5
## 2      1 1 1 0  62.8
## 3      1 0 0 0  46.8
## 4      1 1 0 1  57.0
## 5      2 1 0 0  59.8
## 6      2 1 1 1  58.5
## 7      2 0 0 1  55.5
## 8      2 0 1 0  56.0
## 9      3 0 1 0  62.8
## 10     3 1 1 1  55.8
## 11     3 1 0 0  69.5
## 12     3 0 0 1  55.0
## 13     4 1 0 0  62.0
## 14     4 1 1 1  48.8
## 15     4 0 0 1  45.5
## 16     4 0 1 0  44.2
## 17     5 1 1 0  52.0
## 18     5 0 0 0  51.5
## 19     5 1 0 1  49.8
## 20     5 0 1 1  48.8
## 21     6 1 0 1  57.2
## 22     6 1 1 0  59.0
## 23     6 0 1 1  53.2
## 24     6 0 0 0  56.0

Formando um dataframe

df2 <- data.frame(rep(1:5, each = 4), rep(1:4,5), rnorm(20, 8, 2))
names(df2) <- c("tratamento", "bloco", "produtividade")
df2

##    tratamento bloco produtividade
## 1           1     1      5.612225
## 2           1     2      6.927787
## 3           1     3      8.107283
## 4           1     4     10.672165
## 5           2     1      7.755539
## 6           2     2      7.905604
## 7           2     3     10.774431
## 8           2     4      8.313677
## 9           3     1      3.303216
## 10          3     2      8.722001
## 11          3     3      8.850877
## 12          3     4      5.292971
## 13          4     1      9.479584
## 14          4     2      4.477949
## 15          4     3     10.176468
## 16          4     4      8.657494
## 17          5     1      9.718597
## 18          5     2      9.336306
## 19          5     3      6.127172
## 20          5     4     10.232739

Para saber sobre determinado dataframe, matriz, vetor ou lista:

str(npk)

## 'data.frame':    24 obs. of  5 variables:
##  $ block: Factor w/ 6 levels "1","2","3","4",..: 1 1 1 1 2 2 2 2 3 3 ...
##  $ N    : Factor w/ 2 levels "0","1": 1 2 1 2 2 2 1 1 1 2 ...
##  $ P    : Factor w/ 2 levels "0","1": 2 2 1 1 1 2 1 2 2 2 ...
##  $ K    : Factor w/ 2 levels "0","1": 2 1 1 2 1 2 2 1 1 2 ...
##  $ yield: num  49.5 62.8 46.8 57 59.8 58.5 55.5 56 62.8 55.8 ...

str(df2)

## 'data.frame':    20 obs. of  3 variables:
##  $ tratamento   : int  1 1 1 1 2 2 2 2 3 3 ...
##  $ bloco        : int  1 2 3 4 1 2 3 4 1 2 ...
##  $ produtividade: num  5.61 6.93 8.11 10.67 7.76 ...

Acesso de colunas e linhas de um objeto (matriz, vetor, lista ou dataframe)

v_2[3]   # retorna o terceiro valor do vetor v_2

## [1] 40

m2[,2]   # retorna a segunda coluna da matriz

## [1]  6  7  8  9 10

m2[1,]   # retorna a primeira linha da matriz

## [1]  1  6 11 16

m2[1, 2]   # retorna o valor em determinada linha e coluna

## [1] 6

npk$yield # retorna coluna específica de dataframe (o $ funciona apenas em listas e dataframe),

##  [1] 49.5 62.8 46.8 57.0 59.8 58.5 55.5 56.0 62.8 55.8 69.5 55.0 62.0 48.8
## [15] 45.5 44.2 52.0 51.5 49.8 48.8 57.2 59.0 53.2 56.0

l1$Curso

## [1] "Agronomia"

df2$produtividade # retorna a coluna produtividade do dataframe

##  [1]  5.612225  6.927787  8.107283 10.672165  7.755539  7.905604 10.774431
##  [8]  8.313677  3.303216  8.722001  8.850877  5.292971  9.479584  4.477949
## [15] 10.176468  8.657494  9.718597  9.336306  6.127172 10.232739

Funções

log(5, base = 10)

## [1] 0.69897

sqrt(4)

## [1] 2

pi/5

## [1] 0.6283185

mean(1:5)

## [1] 3

sum(1,3,4)

## [1] 8

round(10/3)

## [1] 3

round(sum(1.5,mean(1:10),log(3)))

## [1] 8

- Criando as próprias funções
- A criação de funções é uma forma de simplificar o código e torná-los mais práticos.

soma <- function(x = 0, y = 0, z = 0, w =0 , v = 0) {
  resposta <- x + y + z + w + v
  return(resposta)
}

soma(5, 7)

## [1] 12

    Regra de Três

soma(5)

## [1] 5

regratres <- function(a = 0, b = 0, c = 0) {
  resposta <- (c*b)/a
}

x <- regratres(50, 100, 25)
x

## [1] 50

    Equação da Continuidade

eq.cont <- function(v1= 0, a2 = 0, v2 = 0) {
  resposta <- (a2*v2)/v1
}

x <- eq.cont(10, 57, 12)
x

## [1] 68.4

Test T

data("sleep")  # Arquivo de dados exemplo
str(sleep)

## 'data.frame':    20 obs. of  3 variables:
##  $ extra: num  0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 0 2 ...
##  $ group: Factor w/ 2 levels "1","2": 1 1 1 1 1 1 1 1 1 1 ...
##  $ ID   : Factor w/ 10 levels "1","2","3","4",..: 1 2 3 4 5 6 7 8 9 10 ...

t.test(data = sleep, extra ~ group)

## 
##  Welch Two Sample t-test
## 
## data:  extra by group
## t = -1.8608, df = 17.776, p-value = 0.07939
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -3.3654832  0.2054832
## sample estimates:
## mean in group 1 mean in group 2 
##            0.75            2.33

Anova

data("npk")
str(npk)

## 'data.frame':    24 obs. of  5 variables:
##  $ block: Factor w/ 6 levels "1","2","3","4",..: 1 1 1 1 2 2 2 2 3 3 ...
##  $ N    : Factor w/ 2 levels "0","1": 1 2 1 2 2 2 1 1 1 2 ...
##  $ P    : Factor w/ 2 levels "0","1": 2 2 1 1 1 2 1 2 2 2 ...
##  $ K    : Factor w/ 2 levels "0","1": 2 1 1 2 1 2 2 1 1 2 ...
##  $ yield: num  49.5 62.8 46.8 57 59.8 58.5 55.5 56 62.8 55.8 ...

a1<- aov(data = npk, yield ~ N*P*K + block)
summary(a1)

##             Df Sum Sq Mean Sq F value  Pr(>F)   
## N            1  189.3  189.28  12.259 0.00437 **
## P            1    8.4    8.40   0.544 0.47490   
## K            1   95.2   95.20   6.166 0.02880 * 
## block        5  343.3   68.66   4.447 0.01594 * 
## N:P          1   21.3   21.28   1.378 0.26317   
## N:K          1   33.1   33.14   2.146 0.16865   
## P:K          1    0.5    0.48   0.031 0.86275   
## Residuals   12  185.3   15.44                   
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Teste de normalidade por Shapiro-Wilk

shapiro.test(a1$residuals) # p>0.05 (normal)

## 
##  Shapiro-Wilk normality test
## 
## data:  a1$residuals
## W = 0.96875, p-value = 0.6363

Regressão linear

lm1 <- lm(data=iris, Sepal.Length ~ Petal.Length)
summary(lm1)

## 
## Call:
## lm(formula = Sepal.Length ~ Petal.Length, data = iris)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.24675 -0.29657 -0.01515  0.27676  1.00269 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(>|t|)    
## (Intercept)   4.30660    0.07839   54.94   <2e-16 ***
## Petal.Length  0.40892    0.01889   21.65   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.4071 on 148 degrees of freedom
## Multiple R-squared:   0.76,  Adjusted R-squared:  0.7583 
## F-statistic: 468.6 on 1 and 148 DF,  p-value: < 2.2e-16

lm2 <- lm(iris$Sepal.Length ~ iris$Petal.Length + iris$Petal.Width)
summary(lm2)

## 
## Call:
## lm(formula = iris$Sepal.Length ~ iris$Petal.Length + iris$Petal.Width)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1.18534 -0.29838 -0.02763  0.28925  1.02320 
## 
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)    
## (Intercept)        4.19058    0.09705  43.181  < 2e-16 ***
## iris$Petal.Length  0.54178    0.06928   7.820 9.41e-13 ***
## iris$Petal.Width  -0.31955    0.16045  -1.992   0.0483 *  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.4031 on 147 degrees of freedom
## Multiple R-squared:  0.7663, Adjusted R-squared:  0.7631 
## F-statistic:   241 on 2 and 147 DF,  p-value: < 2.2e-16

Aplicando os modelos de regressão linear com funções

    Obtendo os coeficientes:

model <- lm(iris$Sepal.Length ~ iris$Petal.Length+iris$Sepal.Width)
coef <- model$coefficients

    Formando uma função:

se_len <- function(petal.length = 0, sepal.width = 0) {
y <- (coef[1]+(coef[2]*petal.length) + (coef[3]*sepal.width))
return(y)
}

    Aplicando a função:

x <- se_len(iris[,3], iris[,2])

Gráfico com valores preditos e reais:

plot(x, iris$Sepal.Length)

summary(lm(iris$Sepal.Length ~ x))

## 
## Call:
## lm(formula = iris$Sepal.Length ~ x)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.96159 -0.23489  0.00077  0.21453  0.78557 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(>|t|)    
## (Intercept) 2.321e-15  2.112e-01    0.00        1    
## x           1.000e+00  3.585e-02   27.89   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.3322 on 148 degrees of freedom
## Multiple R-squared:  0.8402, Adjusted R-squared:  0.8391 
## F-statistic:   778 on 1 and 148 DF,  p-value: < 2.2e-16

função extra:

tapply(npk$yield, npk$block, mean) # média de produtividade para cáda bloco

##      1      2      3      4      5      6 
## 54.025 57.450 60.775 50.125 50.525 56.350

tapply(npk$yield, npk$N, mean) # média de produtividade para cada nível de N

##        0        1 
## 52.06667 57.68333

tapply(npk$yield, npk$N, sum) # soma

##     0     1 
## 624.8 692.2

tapply(npk$yield, npk$N, sd) # desvio padrão

##        0        1 
## 5.377957 5.791347

tapply(npk$yield, npk$N, var) #variancia

##        0        1 
## 28.92242 33.53970

tapply(npk$yield, npk$N, min) # mínimo

##    0    1 
## 44.2 48.8

tapply(npk$yield, npk$N, max) # máximo

##    0    1 
## 62.8 69.5

tapply(npk$yield, npk$N, median) # mediana

##     0     1 
## 52.35 57.85

Pacote dplyr e magrittr - Manipulação de dados
o Pacote magrittr tem o operador %>% (pipe) que evita fazer empilhamento de funções e criação de objetos desnecessários que podem atrapalhar a fucionalidade do código.

library(tidyverse) # chama todos os pacotes do tidyverse
library(dplyr) # chama só o dplyr
library(magrittr) # para usar o pipe ( %>% )

aim <- iris %>%  group_by(Species) %>% summarise_all(c(mean = mean,sd = sd)) #Média e desvio ara cada espécies com o uso do %>%

# sem o uso de %>%  ficaria:

aim <- group_by(.data = iris, Species)
aim <- summarise_all(.tbl = aim, c(mean = mean, sd = sd)) # usa o c() para concaternar mais de uma função.

# Pode fazer de apenas uma variável também

aim <- iris %>% group_by(Species) %>% summarise(mean = mean(Sepal.Width))

Obs.: Quando se tem vários fatores que devem cada um ter a sua média (Experimentos fatoriais) quando usar o group_by() inserir todos os fatores:

aim <- npk %>% group_by(N,P,K) %>% summarise(yield = mean(yield)) # Tipo um trifatorial

Filtrar por determinado valor de coluna específica

aim <- iris %>% filter(Species == "setosa") # pode ser asism
aim <- filter(.data = iris, Species == "virginica") # ou assim

Selecionar apenas colunas de interesse

aim <- iris %>% select(Species, Petal.Length, Sepal.Length)

Pacote Reshape2
Melt - Fazer várias colunas (variáveis) virarem uma única coluna com adição dos nomes de cada variável em suas respectivas observações.

library(reshape2)

data <-  melt(iris,id.vars = "Species") # as colunas que serão mantidas devem ser indicadas em "id.vars"

# perceba que todas as colunas com exceção de "Species" viraram uma única coluna denominada "value" com os respectivos nomes na coluna "variable" 

# Para alterar os nomes das colunas criadas (variable e value) só adicionar os argumentos "variable.name" e "value.name"

data <- melt(iris, id.vars = "Species", variable.name = "Variáveis", value.name = "Medidas") 

Rafael Henrique Pertille
henriquepertille@gmail.com

